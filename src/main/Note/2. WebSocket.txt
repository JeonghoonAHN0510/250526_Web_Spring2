[ HTTP ]
- HyperText Transfer Protocol
- 클라이언트 <-------- request / response --------> 서버
- HTTP 기반의 통신은 요청(request)가 있을 경우에만 응답(response)이 가능하다.
- 통신 상태를 유지하지않음 -> 통신할 때마다 연결/매핑해야한다. -> '무상태'

[ WebSocket ]
- ws 프로토콜을 기반으로 클라이언트와 서버 사이의 **지속적인 양방향** 연결이 가능하다.
- 특징
    1) 지속적인 양방향 연결 -> '상태'
    2) Socket : 통신의 종착점( 엔드포인트 : 통신을 주고받는 도착지점 )
    3) 클라이언트 소켓이 서버 소켓에게 연결 요청
- 사용처
    1) 실시간 통신 : 채팅, 게임
    2) 알림, 보안 등등
- 스프링 웹서버 소켓 구현
    1) 'websocket' 라이브러리 설치
    2) 서버웹소켓(핸들러) 클래스 생성
        (1) 'ChatHandler' 임의의 서버소켓으로 사용할 클래스 생성
        (2) 'TextWebSocketHandler' 로부터 상속받아 웹소켓 기능(메소드)을 오버라이딩(재구현)
            ** 상속 : 특정한 클래스로부터 클래스 정보(멤버변수/메소드)를 물려받는 행위
        (3) @Component를 클래스에 어노테이션함으로써 스프링 컨테이너에 bean 등록
        (4) 상속받은 주요 메소드
            1. 클라이언트 소켓이 서버 소컷과 연결을 성공했을 때 실행되는 메소드
               -> afterConnectionEstablished(WebSocketSession session){}
            2. 클라이언스 소켓이 서버 소켓과 연결이 끊겼을 때 실행되는 메소드
               -> afterConnectionClosed(WebSocketSession session, CloseStatus status){}
            3. 클라이언트 소켓이 서버 소켓에게 메시지를 보냈을 떄 실행되는 메소드
               -> handleTextMessage(WebSocketSession session, TextMessage message){}
    3) 서버웹소켓 클래스와 연결/매핑
        (1) @Configuration + @EnableWebSocket 어노테이션 추가
        (2) @Autowired private ChatHandler chatHandler;
        (3) 개발자가 만든 서버웹소켓(핸들러) 객체들을 스프링이 알 수 있게 경로를 등록한다.
            -> registerWebSocketHandlers( WebSocketHandlerRegistry registry ){}
    4) 클라이언트 JS 웹소켓 구현
        ** 주의할 점 : 브라우저마다 클라이언트 웹소켓(세션 저장소)이 별도로 사용된다.
        (1) 서버 웹소켓 경로로부터 클라이언트 웹소켓 구현
            -> new WebSocket("ws웹소켓 서버주소");
            -> ws웹소켓 서버주소 : WebSocketConfig에서 정의한 주소
            -> 새로고침되면 모든 JS의 객체는 초기화 -> 클라이언트 소켓도 초기화
        (2) 클라이언트 웹소켓 주요 메소드
            * event 매개변수 : 각 이벤트의 정보가 있는 객체
            1. onopen( event ) : 서버소켓과 연결이 성공되었을 때 실행되는 메소드
            2. onclose( event ) : 서버소켓과 연결이 종료되었을 때 실행되는 메소드
            3. onerror( event ) : 서버소켓과 연결 중 에러가 발생했을 때 실행되는 메소드
            4. onmessage( event ) : 서버소켓으로부터 메시지를 받았을 때 실행되는 메소드
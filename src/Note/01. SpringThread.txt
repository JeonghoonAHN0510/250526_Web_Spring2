[ Thread(스레드) ]
- 프로세스 내에서 실행되는 작업 단위/흐름
- 하나의 프로세스에는 최소 하나의 스레드가 존재
- Java는 main() 메소드 실행 시, main 스레드 1개가 실행된다.

[ Multi Thread ]
- main 스레드 외의 새로운 작업 스레드 실행
- 병렬 처리할 때, 멀티스레드 사용

[ Spring Thread ]
- Spring은 기본적으로 멀티스레드 환경 지원 -> 대규모 환경
       vs Node.js는 단일스레드 환경 지원 -> 소규모 환경
- 사용처
    1) REST API : 여러 사람들이 서로 다른 URL을 요청할 때, 서로 다른 스레드가 처리한다.
    2) JDBC
    3) 동기화/비동기화

[ Spring 동기화 vs 비동기화 ]
- 동기화   : 여러 스레드가 하나의 메소드를 호출할 때, **요청 순서대로** 처리하는 방법
    1) 요청 순서 보장 O
    2) Spring 스레드는 기본적으로 Controller에서 동기화 처리
    3) 메소드가 끝날때까지 **대기상태**
    4) 사용처 : 기본 CRUD
       -> 사용자가 기다릴 필요가 있는 영역
- 비동기화 : 여러 스레드가 하나의 메소드를 호출할 때, **처리 순서대로** 처리하는 방법
    1) 요청 순서 보장 X
    2) Spring 스레드에서 비동기화 요청 시, 해당 메소드에 @Async 어노테이션 추가
    3) 메소드를 먼저 반환하고, 백그라운드에서 처리한다.
    4) 사용처 : 대량 데이터 연산처리, 외부 API 연동, 이메일 전송, 푸시 알림, 로그 등등
       -> 사용자가 기다릴 필요가 없는 영역
    5) 사용법
        (1) AppStart 클래스에 @EnableAsync 어노테이션을 추가하여, 비동기화 기능을 활성화한다.
        (2) 비동기화할 Service 메소드에 @Async 어노테이션을 추가하여, 비동기화 처리한다.
            -> 새로운 작업 스레드가 생성되면서, 백그라운드에서 실행 처리된다.
- 스레드풀 : 한정된 스레드 개수를 가지고 작업
    1) 대량의 작업 스레드가 생성되는 것을 방지하고, 안정적인 병렬 작업을 가능케한다.
    2) Spring 스레드풀 커스텀 방법
        (1) MVC 폴더 내 Config 폴더를 생성하여 -> ThreadPoolConfig 클래스 생성
        (2) ThreadPoolConfig 클래스에 @Configuration 어노테이션 추가
            -> @Configuration을 추가함으로써 스프링 컨테이너에 Bean을 등록한다.
        (3) Executor를 이용하여, 멀티스레스 설정 및 @Bean 어노테이션 추가

[ Spring Scheduling ]
- 일정한 간격으로 특정 서비스를 자동 실행
- 자동화를 구현하기 위하여 사용
- 사용법
    1) AppStart 클래스에 @EnableScheduling 어노테이션을 추가하여, 스케줄링 기능을 활성화한다.
    2) 자동화할 Service 메소드에 @Scheduled 어노테이션을 추가하여, 자동화 처리한다.
       -> cron = "초 분 시 일 월 요일" -> 서버 시스템의 날짜/시간 기준 - **사용권장**
       -> fixedRate = 밀리초
       -> fixedDelay = 밀리초
    3) cron 예시
        (1) 주말(토/일) 오전 10시마다 : @Scheduled( cron = "0 0 10 * * 0,6" )
        (2) 일요일 오전 9시마다 : @Scheduled( cron = "0 0 9 * * 0" )
        (3) 매월 1일 오전 8시마다 : @Schedule( cron = "0 0 8 1 * *" )
    4) 주의할 점 : 백그라운드 기반의 처리이므로 HTTP response(응답)이 불가능하다.
       -> 해결방안 : Socket(연결 유지) 방식으로 응답처리